/*
* This source file is part of an OSTIS project. For the latest info, see http://ostis.net
* Distributed under the MIT License
* (See accompanying file COPYING.MIT or copy at http://opensource.org/licenses/MIT)
*/

#include "RuleApplicationManager.hpp"

#include <sc-memory/sc_addr.hpp>
#include <sc-agents-common/utils/GenerationUtils.hpp>
#include <sc-agents-common/utils/IteratorUtils.hpp>
#include <sc-agents-common/utils/CommonUtils.hpp>
#include <sc-agents-common/utils/AgentUtils.hpp>
#include <sc-agents-common/keynodes/coreKeynodes.hpp>
#include <sc-memory/sc_link.hpp>

#include "searcher/RuleConstructionsSearcher.hpp"
#include "keynodes/Keynodes.hpp"
#include "utils/RuleCheckResultUtils.hpp"

using namespace std;
using namespace rulesApplicationModule;
using namespace scAgentsCommon;

RuleApplicationManager::RuleApplicationManager(ScMemoryContext * context)
{
  this->context = context;
  this->ruleConstructionsSearcher = make_unique<RuleConstructionsSearcher>(context);
  this->templateSearcher = make_unique<TemplateSearcher>(context);
}

void RuleApplicationManager::applyRules(
      ScAddr const & ruleSet,
      ScAddr const & inputStructure,
      ScAddr const & resultStructure)
{
  ScAddrVector rules = utils::IteratorUtils::getAllWithType(context, ruleSet, ScType::NodeConst);
  size_t rulesNumber = rules.size();
  size_t ruleNumber = 1;
  for (auto & rule : rules)
  {
    SC_LOG_DEBUG("RuleApplicationManager: trying to use rule: " + context->HelperGetSystemIdtf(rule) +
                 " (" + to_string(ruleNumber) + "/" + to_string(rulesNumber) +")");
    applyRule(rule, inputStructure, resultStructure);
    ruleNumber++;
  }
}

void RuleApplicationManager::applyRule(
      ScAddr const & rule,
      ScAddr const & inputStructure,
      ScAddr const & resultStructure)
{
  ScAddr ruleKeyOperation = utils::IteratorUtils::getFirstByOutRelation(
        context,
        rule,
        Keynodes::rrel_main_key_sc_element);

  StatementsCheckResult ruleCheckResult;
  size_t nestingLevel = 0;
  checkOperation(ruleKeyOperation, inputStructure, resultStructure, nestingLevel, ruleCheckResult);

  size_t notSearchedStructuresNum = ruleCheckResult.notSearchedStructures.size();
  if (notSearchedStructuresNum)
  {
    SC_LOG_DEBUG("RuleApplicationManager: unable to perform search "
                 "of " + to_string(notSearchedStructuresNum) + " structures in rule.");

    SC_LOG_DEBUG("RuleApplicationManager: retrying the search, taking into account the additional replacements.");
    searchNotSearchedStructures(ruleCheckResult, inputStructure, resultStructure);
  }

  if (RuleCheckResultUtils::getReplacementCombinationsNumber(ruleCheckResult.replacements))
  {
    applyActions(ruleCheckResult, inputStructure, resultStructure);
    if (allNotFoundStructuresCanBeGenerated(ruleCheckResult))
    {
      SC_LOG_DEBUG("RuleApplicationManager: generating"
                   " " + to_string(ruleCheckResult.notFoundStructures.size()) + " structures.");
      generateNotFoundStructures(ruleCheckResult, resultStructure);
    }
    else
      SC_LOG_DEBUG("RuleApplicationManager: generation will not take place, "
                   "structure, generated by action is not found.");
  }
  else
    SC_LOG_DEBUG("RuleApplicationManager: generation will not take place, nothing was found.");
}

void RuleApplicationManager::searchNotSearchedStructures(
      StatementsCheckResult & ruleCheckResult,
      ScAddr const & inputStructure,
      ScAddr const & resultStructure)
{
  //When we performed all searches, and found all replacements
  //trying to find structures that we previously cannot search with this replacements
  StructuresByNesting notSearchedStructures = ruleCheckResult.notSearchedStructures;
  ruleCheckResult.notSearchedStructures.clear();
  for (auto & structureNestingPair : notSearchedStructures)
    checkAtomicStatement(structureNestingPair.first, inputStructure, resultStructure, structureNestingPair.second, ruleCheckResult);

  //Structures that still can't be searched are added into notFoundStructures set
  ruleCheckResult.notFoundStructures.insert(
        ruleCheckResult.notSearchedStructures.begin(),
        ruleCheckResult.notSearchedStructures.end());
}

void RuleApplicationManager::applyActions(
      StatementsCheckResult & ruleCheckResult,
      ScAddr const & inputStructure,
      ScAddr const & resultStructure)
{
  StructuresByNesting notFoundStructures = ruleCheckResult.notFoundStructures;
  for (auto & structureNestingPair : notFoundStructures)
  {
    if (context->HelperCheckEdge(
          Keynodes::concept_logic_statement_checking_by_action,
          structureNestingPair.first,
          ScType::EdgeAccessConstPosPerm))
      applyActionsOnStatement(
            structureNestingPair.first,
            inputStructure,
            resultStructure,
            structureNestingPair.second,
            ruleCheckResult);
  }
}

void RuleApplicationManager::generateNotFoundStructures(
      StatementsCheckResult & ruleCheckResult,
      ScAddr const & resultStructure)
{
  for (auto & structureNestingPair : ruleCheckResult.notFoundStructures)
  {
    ScTemplate scTemplate;
    ScAddr structure = structureNestingPair.first;
    context->HelperBuildTemplate(scTemplate, structure);

    vector<string> structureVariablesIdentifiers =
          ruleConstructionsSearcher->getVariablesNodesSystemIdentifiers(structure);
    vector<ScTemplateParams> paramsForGeneration = generateTemplateParams(
          structureVariablesIdentifiers,
          ruleCheckResult);
    SC_LOG_DEBUG("RuleApplicationManager: generating structure for"
                 " " + to_string(paramsForGeneration.size()) + " params variants.");

    StatementsCheckResult generationResult;
    for (auto & templateParams : paramsForGeneration)
    {
      SearchWithContentResult existenceCheckResult = templateSearcher->searchTemplateInStructure(
            structure,
            resultStructure,
            templateParams);
      if (existenceCheckResult.empty())
      {
        // TODO: remove dependency on specific model.
        //  Replace with the ability to use a set of input structures
        ScIterator3Ptr iter3 = context->Iterator3(
              Keynodes::concept_current_model,
              ScType::EdgeAccessConstPosTemp,
              ScType::NodeConstStruct);

        if (iter3->Next())
        {
          ScAddr model = iter3->Get(2);

          existenceCheckResult =
                templateSearcher->searchTemplateInStructure(structure, model, templateParams);
          if (existenceCheckResult.empty())
          {
            genTemplateWithLinksContentInStructure(
                  scTemplate,
                  templateParams,
                  structure,
                  resultStructure,
                  generationResult);
          }
          else
          {
            SC_LOG_DEBUG("RuleApplicationManager: not generating template for params variant"
                         " - already exist in model.");
            for (auto & item : existenceCheckResult)
            {
              for (size_t i = 0; i < item.Size(); i++)
              {
                if (!context->HelperCheckEdge(resultStructure, item[i], ScType::EdgeAccessConstPosPerm))
                  context->CreateEdge(ScType::EdgeAccessConstPosPerm, resultStructure, item[i]);
              }
            }
            generationResult.add(context, structure, existenceCheckResult, templateParams);
          }
        }
        else
        {
          genTemplateWithLinksContentInStructure(
                scTemplate,
                templateParams,
                structure,
                resultStructure,
                generationResult);
        }
      }
      else
      {
        SC_LOG_DEBUG("RuleApplicationManager: not generating template for params variant"
                     " - already exist in result structure.");
        generationResult.add(context, structure, existenceCheckResult, templateParams);
      }
    }
    ruleCheckResult.extend(generationResult);
  }
}

void RuleApplicationManager::genTemplateWithLinksContentInStructure(
      ScTemplate const & scTemplate,
      ScTemplateParams & templateParams,
      ScAddr const & templateStructure,
      ScAddr const & resultStructure,
      StatementsCheckResult & generationResult)
{
  ScAddrVector links = utils::IteratorUtils::getAllWithType(context, templateStructure, ScType::LinkVar);
  for (auto & varLink : links)
  {
    if (ruleConstructionsSearcher->isKeyElement(templateStructure, varLink))
    {
      string varLinkIdtf = context->HelperGetSystemIdtf(varLink);
      ScAddr linkForGeneration = getLinkForGeneration(templateStructure, varLink);

      ScAddr found;
      if (!templateParams.Get(varLinkIdtf, found) || !found.IsValid())
        templateParams.Add(varLinkIdtf, linkForGeneration);
    }
  }

  ScTemplateGenResult templateGenResult;
  context->HelperGenTemplate(scTemplate, templateGenResult, templateParams);
  for (size_t generatedElementIndex = 0;
       generatedElementIndex < templateGenResult.Size(); generatedElementIndex++)
  {
    ScAddr element = templateGenResult[generatedElementIndex];
    if (!context->HelperCheckEdge(resultStructure, element, ScType::EdgeAccessConstPosPerm))
      context->CreateEdge(ScType::EdgeAccessConstPosPerm, resultStructure, element);
  }
  generationResult.add(context, templateStructure, templateGenResult);
}

ScAddr RuleApplicationManager::getLinkForGeneration(ScAddr const & structure, ScAddr const & varLink)
{
  ScLink varScLink = ScLink(*context, varLink);
  string linkContent = varScLink.GetAsString();
  vector<ScAddr> foundLinks = context->FindLinksByContent(linkContent);
  if (!foundLinks.empty())
  {
    for (auto const & link : foundLinks)
    {
      if (link.IsValid() && context->GetElementType(link).IsConst())
        return link;
    }
  }


  ScAddr newLink = context->CreateLink();
  ScLink generatedLink = ScLink(*context, newLink);
  generatedLink.Set(linkContent);
  return newLink;
}

void RuleApplicationManager::checkOperation(
      ScAddr const & operationTuple,
      ScAddr const & inputStructure,
      ScAddr const & resultStructure,
      size_t const & nestingLevel,
      StatementsCheckResult & checkResult)
{
  if (utils::CommonUtils::checkType(context, operationTuple, ScType::EdgeUCommonConst))
  {
    if (context->HelperCheckEdge(Keynodes::nrel_equivalence, operationTuple, ScType::EdgeAccessConstPosPerm))
      checkEquivalence(operationTuple, inputStructure, resultStructure, nestingLevel, checkResult);
    else
      throw runtime_error("RuleApplicationManager: "
                          "only recording equivalence as an undirected pair is supported at this moment.");
  }
  else
  {
    if (context->HelperCheckEdge(Keynodes::nrel_conjunction, operationTuple, ScType::EdgeAccessConstPosPerm))
      checkConjunction(operationTuple, inputStructure, resultStructure, nestingLevel, checkResult);
    else
      throw runtime_error("RuleApplicationManager: "
                          "only recording conjunction as an tuple node is supported at this moment.");
  }
}

void RuleApplicationManager::checkConjunction(
      ScAddr const & conjunctionNode,
      ScAddr const & inputStructure,
      ScAddr const & resultStructure,
      size_t const & nestingLevel,
      StatementsCheckResult & checkResult)
{
  ScIterator3Ptr iterator3Ptr = context->Iterator3(conjunctionNode, ScType::EdgeAccessConstPosPerm, ScType::Unknown);

  while (iterator3Ptr->Next())
    checkStatement(iterator3Ptr->Get(2), inputStructure, resultStructure, nestingLevel, checkResult);
}

void RuleApplicationManager::checkEquivalence(
      ScAddr const & equivalenceEdge,
      ScAddr const & inputStructure,
      ScAddr const & resultStructure,
      size_t const & nestingLevel,
      StatementsCheckResult & checkResult)
{
  ScAddr firstStatement, secondStatement;
  context->GetEdgeInfo(equivalenceEdge, firstStatement, secondStatement);

  StatementsCheckResult firstStatementCheckResult = StatementsCheckResult();
  checkStatement(firstStatement, inputStructure, resultStructure, nestingLevel, checkResult);

  StatementsCheckResult secondStatementCheckResult = StatementsCheckResult();
  checkStatement(secondStatement, inputStructure, resultStructure, nestingLevel, checkResult);
}

void RuleApplicationManager::checkStatement(
      ScAddr const & statement,
      ScAddr const & inputStructure,
      ScAddr const & resultStructure,
      size_t const & nestingLevel,
      StatementsCheckResult & checkResult)
{
  if (utils::CommonUtils::checkType(context, statement, ScType::NodeConstStruct))
    checkAtomicStatement(statement, inputStructure, resultStructure, nestingLevel, checkResult);
  else
    checkOperation(statement, inputStructure, resultStructure, nestingLevel + 1, checkResult);
}

void RuleApplicationManager::checkAtomicStatement(
      ScAddr const & statement,
      ScAddr const & inputStructure,
      ScAddr const & resultStructure,
      size_t const & nestingLevel,
      StatementsCheckResult & checkResult)
{
  vector<string> structureVariablesIdentifiers =
        ruleConstructionsSearcher->getVariablesNodesSystemIdentifiers(statement);
  Replacements replacements = checkResult.getUniqueReplacements(structureVariablesIdentifiers);
  checkResult.printReplacementsInDebug(context);

  if (replacements.empty())
    checkStatementForEmptyReplacements(statement, inputStructure, nestingLevel, checkResult);
  else
  {
    checkStatementForNonEmptyReplacements(
          statement,
          structureVariablesIdentifiers,
          inputStructure,
          resultStructure,
          nestingLevel,
          checkResult);
  }
}

void RuleApplicationManager::checkStatementForEmptyReplacements(
      ScAddr const & statement,
      ScAddr const & inputStructure,
      size_t const & nestingLevel,
      StatementsCheckResult & checkResult)
{
  if (ruleConstructionsSearcher->isContainsConstants(statement))
  {
    vector<ScTemplateSearchResultItem> statementSearchResult =
          templateSearcher->searchTemplateInStructure(statement, inputStructure);

    checkResult.extend(context, statement, nestingLevel, statementSearchResult);
  }
  else
    checkResult.notSearchedStructures.insert({ statement, nestingLevel });
}

void RuleApplicationManager::checkStatementForNonEmptyReplacements(
      ScAddr const & statement,
      vector<string> const & statementVariablesIdentifiers,
      ScAddr const & inputStructure,
      ScAddr const & resultStructure,
      size_t const & nestingLevel,
      StatementsCheckResult & checkResult)
{
  vector<ScTemplateParams> paramsForSearch = generateTemplateParams(statementVariablesIdentifiers, checkResult);
  if (!paramsForSearch.empty())
  {
    bool isFound = false;
    StatementsCheckResult statementCheckResult;
    for (const auto & templateParams : paramsForSearch)
    {
      vector<ScTemplateSearchResultItem> statementSearchResult =
            templateSearcher->searchTemplateInStructure(statement, inputStructure, templateParams);

      if (!statementSearchResult.empty())
      {
        statementCheckResult.add(context, statement, statementSearchResult, templateParams);
        isFound = true;
      }
    }
    // We need to find everything before merge
    // because extend logic discards variants for which not the entire construction has been found
    if (isFound)
      checkResult.extend(statementCheckResult);
    else
      checkResult.notFoundStructures.insert({ statement, nestingLevel });
  }
  else
  {
    vector<ScTemplateSearchResultItem> statementSearchResult =
          templateSearcher->searchTemplateInStructure(statement, inputStructure);

    checkResult.extend(context, statement, nestingLevel, statementSearchResult);
  }
}

void RuleApplicationManager::applyActionsOnStatement(
      ScAddr const & statement,
      ScAddr const & inputStructure,
      ScAddr const & resultStructure,
      size_t const & nestingLevel,
      StatementsCheckResult & checkResult)
{
  ScAddrVector relationsVector = ruleConstructionsSearcher->getNoroleRelations(statement);
  for (auto const & relation: relationsVector)
  {
    ScAddr actionClass = utils::IteratorUtils::getFirstByInRelation(
          context,
          relation,
          Keynodes::nrel_action_possible_result);
    bool actionIsApplied = false;
    if (actionClass.IsValid())
    {
      vector<pair<string, string>> connectedByRelationVariablesIdentifiers =
            ruleConstructionsSearcher->getConnectedByRelationVariablesIdentifiesrs(relation, statement);

      for (auto const & variablesPair: connectedByRelationVariablesIdentifiers)
      {
        Replacements replacements = checkResult.getUniqueReplacements({ variablesPair.first, variablesPair.second });
        size_t combinationsNumber = RuleCheckResultUtils::getReplacementCombinationsNumber(replacements);

        for (size_t combinationIndex = 0; combinationIndex < combinationsNumber; combinationIndex++)
        {
          ScAddr firstVariableRepalcement = replacements[variablesPair.first][combinationIndex];
          ScAddr secondVariableRepalcement = replacements[variablesPair.second][combinationIndex];
          ScAddr action = formActionInstance(
                actionClass,
                { firstVariableRepalcement, secondVariableRepalcement, inputStructure });

          SC_LOG_DEBUG("RuleApplicationManager: called action.");
          context->CreateEdge(
                ScType::EdgeAccessConstPosPerm,
                CoreKeynodes::question_initiated,
                action);
          if (utils::AgentUtils::waitAgentResult(context, action, WAIT_TIME))
          {
            if (context->HelperCheckEdge(CoreKeynodes::question_finished_successfully, action, ScType::EdgeAccessConstPosPerm))
            {
              actionIsApplied = true;
              SC_LOG_DEBUG("RuleApplicationManager: action finished successfully.");
            }
            else
              SC_LOG_DEBUG("RuleApplicationManager: action finished unsuccessfully.");
          }
          else
            SC_LOG_ERROR("RuleApplicationManager: action wait time expired.");
        }
      }
    }
    if (actionIsApplied)
    {
      checkResult.notFoundStructures.erase({ statement, nestingLevel });
      checkAtomicStatement(statement, inputStructure, resultStructure, nestingLevel, checkResult);
    }
  }
}

ScAddr RuleApplicationManager::formActionInstance(ScAddr const & actionClass, ScAddrVector const & arguments)
{
  ScAddr action = context->CreateNode(ScType::NodeConst);
  context->CreateEdge(ScType::EdgeAccessConstPosPerm, actionClass, action);

  size_t argumentRoleRelationIndex = 1;
  for (auto const & argument: arguments)
  {
    ScAddr argumentAccessArc = context->CreateEdge(
          ScType::EdgeAccessConstPosPerm,
          action,
          argument);
    context->CreateEdge(
          ScType::EdgeAccessConstPosPerm,
          utils::IteratorUtils::getRoleRelation(context, argumentRoleRelationIndex),
          argumentAccessArc);
    argumentRoleRelationIndex++;
  }

  return action;
}

vector<ScTemplateParams> RuleApplicationManager::generateTemplateParams(
      vector<string> const & structureVariablesIdentifiers,
      StatementsCheckResult const & checkResults)
{
  Replacements replacements = checkResults.getUniqueReplacements(structureVariablesIdentifiers);

  vector<ScTemplateParams> generationTemplateParams;
  size_t combinationsNumber = RuleCheckResultUtils::getReplacementCombinationsNumber(replacements);
  generationTemplateParams.reserve(combinationsNumber);
  for (size_t replacementsIndex = 0; replacementsIndex < combinationsNumber; replacementsIndex++)
  {
    ScTemplateParams templateParams;
    for (auto & replacementPair : replacements)
      templateParams.Add(replacementPair.first, replacementPair.second[replacementsIndex]);
    generationTemplateParams.push_back(templateParams);
  }

  return generationTemplateParams;
}

bool RuleApplicationManager::allNotFoundStructuresCanBeGenerated(StatementsCheckResult const & checkResults)
{
  for (auto const & structureWithNestingPair: checkResults.notFoundStructures)
  {
    if (context->HelperCheckEdge(
          Keynodes::concept_logic_statement_checking_by_action,
          structureWithNestingPair.first,
          ScType::EdgeAccessConstPosPerm))
      return false;
  }

  return true;
}
